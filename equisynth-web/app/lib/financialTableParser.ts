/**
 * Financial Table Parser
 * Identifies and structures financial statements (Income Statement, Balance Sheet, Cash Flow)
 * from raw table data extracted from SEC filings
 */

export interface FinancialTable {
	type: "income_statement" | "balance_sheet" | "cash_flow" | "segment" | "other";
	title: string;
	headers: string[];
	rows: Array<{
		label: string;
		values: (string | number)[];
	}>;
	metadata: {
		periods: string[];
		hasNegatives: boolean;
		hasPercentages: boolean;
	};
}

/**
 * Detect if a table is likely an Income Statement
 */
function isIncomeStatement(table: string[][]): boolean {
	const text = table.flat().join(" ").toLowerCase();
	const keywords = [
		"revenue",
		"net sales",
		"operating income",
		"gross profit",
		"net income",
		"earnings per share",
		"cost of revenue",
		"income from operations",
	];
	return keywords.filter((k) => text.includes(k)).length >= 3;
}

/**
 * Detect if a table is likely a Balance Sheet
 */
function isBalanceSheet(table: string[][]): boolean {
	const text = table.flat().join(" ").toLowerCase();
	const keywords = [
		"total assets",
		"total liabilities",
		"stockholders' equity",
		"current assets",
		"current liabilities",
		"cash and cash equivalents",
		"retained earnings",
	];
	return keywords.filter((k) => text.includes(k)).length >= 3;
}

/**
 * Detect if a table is likely a Cash Flow Statement
 */
function isCashFlowStatement(table: string[][]): boolean {
	const text = table.flat().join(" ").toLowerCase();
	
	// Strong indicators (any 2 of these means it's definitely cash flow)
	const strongKeywords = [
		"cash generated by operating",
		"cash flows from operating",
		"net cash provided by operating",
		"net cash used in operating",
		"cash generated by/(used in) investing",
		"cash flows from investing",
		"cash flows from financing",
	];
	const strongMatches = strongKeywords.filter((k) => text.includes(k)).length;
	if (strongMatches >= 2) return true;
	
	// Weak indicators (need 3+ to match)
	const weakKeywords = [
		"operating activities",
		"investing activities",
		"financing activities",
		"cash flow",
		"depreciation",
		"cash and cash equivalents, beginning",
		"cash and cash equivalents, ending",
	];
	const weakMatches = weakKeywords.filter((k) => text.includes(k)).length;
	
	// If we have 1 strong match + 1 weak match, or 3+ weak matches
	return (strongMatches >= 1 && weakMatches >= 1) || weakMatches >= 3;
}

/**
 * Clean and normalize cell values
 */
function cleanCellValue(val: string): string | number {
	if (!val || val.trim() === "" || val === "â€”" || val === "-") {
		return null as any; // Return null for empty cells
	}
	
	// First, decode HTML entities
	let cleaned = val
		.replace(/&#160;/g, ' ')  // Non-breaking space
		.replace(/&nbsp;/g, ' ')   // Non-breaking space
		.replace(/&amp;/g, '&')    // Ampersand
		.replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(dec)) // Numeric entities
		.trim()
		.replace(/\s+/g, " ");
	
	// Try to parse as number
	// Common formats: 1,234.56  (1,234)  $1,234  123.45%  -1,234  (1,234.56)  (2935)  2935
	// Improved regex to handle both comma-separated and non-comma numbers
	const numMatch = cleaned.match(/^[\$]?[\-]?\(?(\d{1,3}(?:,\d{3})*(?:\.\d+)?|\d+(?:\.\d+)?)\)?[\%]?$/);
	if (numMatch) {
		const num = parseFloat(numMatch[1].replace(/,/g, ""));
		// If parentheses OR starts with minus, it's negative
		if (cleaned.includes("(") && cleaned.includes(")") || cleaned.startsWith("-")) {
			return -num;
		}
		return num;
	}
	
	return cleaned;
}

/**
 * Extract period headers (dates, years, quarters)
 */
function extractPeriods(headerRow: string[]): string[] {
	return headerRow
		.slice(1) // Skip first column (usually label)
		.map((h) => h.trim())
		.filter((h) => h.length > 0);
}

/**
 * Parse a single financial table
 */
export function parseFinancialTable(rawTable: string[][]): FinancialTable | null {
	if (rawTable.length < 2) return null;

	// Determine table type
	let type: FinancialTable["type"] = "other";
	let title = "Financial Table";
	
	if (isIncomeStatement(rawTable)) {
		type = "income_statement";
		title = "Income Statement";
	} else if (isBalanceSheet(rawTable)) {
		type = "balance_sheet";
		title = "Balance Sheet";
	} else if (isCashFlowStatement(rawTable)) {
		type = "cash_flow";
		title = "Cash Flow Statement";
	}

	// Find the header row - look for dates/years in the first few rows
	let headerRowIndex = 0;
	let headerRow = rawTable[0];
	
	// Check if row 1 contains dates (like "September 28, 2024")
	if (rawTable.length > 1) {
		const secondRow = rawTable[1];
		const hasDatePattern = secondRow.some(cell => {
			const cleaned = cell.trim();
			return /\d{4}/.test(cleaned) || /September|October|November|December|January/.test(cleaned);
		});
		
		if (hasDatePattern) {
			headerRowIndex = 1;
			headerRow = rawTable[1];
		}
	}
	
	// Build headers: include row 0 if headerRowIndex = 1 (unit indicator might be in row 0)
	const headers: string[] = [];
	if (headerRowIndex === 1 && rawTable.length > 0) {
		// Include row 0 in headers for unit detection
		const row0 = rawTable[0].map((h) => h.trim());
		headers.push(...row0);
	}
	headers.push(...headerRow.map((h) => h.trim()));
	const periods = extractPeriods(headerRow);

	// Parse data rows (skip rows up to and including header)
	const rows: FinancialTable["rows"] = [];
	let hasNegatives = false;
	let hasPercentages = false;

	for (let i = headerRowIndex + 1; i < rawTable.length; i++) {
		const row = rawTable[i];
		if (row.length === 0) continue;

		const label = row[0]?.trim() || "";
		if (!label) continue; // Skip empty labels

		const values = row.slice(1).map(cleanCellValue);
		
		// Check for negatives and percentages
		for (const val of values) {
			if (typeof val === "number" && val < 0) hasNegatives = true;
			if (typeof val === "string" && val.includes("%")) hasPercentages = true;
		}

		rows.push({ label, values });
	}

	if (rows.length === 0) return null;

	return {
		type,
		title,
		headers,
		rows,
		metadata: {
			periods,
			hasNegatives,
			hasPercentages,
		},
	};
}

/**
 * Parse all tables and return structured financial tables
 */
export function parseAllFinancialTables(rawTables: string[][][]): FinancialTable[] {
	const results: FinancialTable[] = [];
	
	for (const rawTable of rawTables) {
		const parsed = parseFinancialTable(rawTable);
		if (parsed) {
			results.push(parsed);
		}
	}
	
	return results;
}

/**
 * Extract unit scale factor from table headers
 * SEC filings often indicate units in headers (e.g., "in millions", "in thousands")
 * Also check for variations like "$ in millions", "amounts in millions", etc.
 */
function extractUnitScale(headers: string[]): number {
	const headerText = headers.join(" ").toLowerCase();
	
	// Check for millions (most common in SEC filings)
	if (
		headerText.includes("in millions") || 
		headerText.includes("(in millions)") ||
		headerText.includes("$ in millions") ||
		headerText.includes("amounts in millions") ||
		headerText.includes("millions") && (headerText.includes("$") || headerText.includes("amounts"))
	) {
		return 1_000_000;
	}
	
	// Check for thousands
	if (
		headerText.includes("in thousands") || 
		headerText.includes("(in thousands)") ||
		headerText.includes("$ in thousands") ||
		headerText.includes("amounts in thousands") ||
		headerText.includes("thousands") && (headerText.includes("$") || headerText.includes("amounts"))
	) {
		return 1_000;
	}
	
	// Check for billions
	if (
		headerText.includes("in billions") || 
		headerText.includes("(in billions)") ||
		headerText.includes("$ in billions") ||
		headerText.includes("amounts in billions") ||
		headerText.includes("billions") && (headerText.includes("$") || headerText.includes("amounts"))
	) {
		return 1_000_000_000;
	}
	
	// Default: assume values are already in base units (dollars)
	// NOTE: Most SEC filings use millions, but we can't assume without explicit indicator
	return 1;
}

/**
 * Get the latest (most recent) numeric value from a row
 * Uses periods array to determine which column is the latest period
 * In SEC filings, latest period is usually the FIRST column (e.g., 2024, 2023, 2022)
 */
function getLatestNumericValue(values: (string | number)[], periods?: string[]): number | null {
	// If periods are provided, find the latest period and get its value
	if (periods && periods.length > 0) {
		// Extract years from periods and find the latest year
		const years: number[] = [];
		const periodToIndex = new Map<string, number>();
		
		periods.forEach((period, index) => {
			// Try to extract year from period (e.g., "2024", "September 28, 2024", "2024-09-28")
			const yearMatch = period.match(/\b(20\d{2})\b/);
			if (yearMatch) {
				const year = parseInt(yearMatch[1], 10);
				years.push(year);
				periodToIndex.set(period, index);
			}
		});
		
		if (years.length > 0) {
			// Find the latest year
			const latestYear = Math.max(...years);
			// Find the FIRST period with the latest year (latest period is usually first column in SEC filings)
			for (let i = 0; i < periods.length; i++) {
				const period = periods[i];
				const yearMatch = period.match(/\b(20\d{2})\b/);
				if (yearMatch && parseInt(yearMatch[1], 10) === latestYear) {
					// Found the latest period - get value from corresponding column
					if (i < values.length) {
						const val = values[i];
						if (typeof val === 'number' && !isNaN(val) && val !== null) {
							return val;
						}
					}
					break; // Use first occurrence of latest year
				}
			}
		}
	}
	
	// Fallback: try to find the FIRST numeric value (latest period is usually first column in SEC filings)
	for (const val of values) {
		if (typeof val === 'number' && !isNaN(val) && val !== null) {
			return val;
		}
	}
	
	// Final fallback: try last numeric value
	for (let i = values.length - 1; i >= 0; i--) {
		const val = values[i];
		if (typeof val === 'number' && !isNaN(val) && val !== null) {
			return val;
		}
	}
	return null;
}

/**
 * Extract key metrics from parsed financial tables
 */
export function extractKeyMetrics(tables: FinancialTable[]): Record<string, any> {
	const metrics: Record<string, any> = {};

	// Income Statement metrics
	const incomeStatement = tables.find((t) => t.type === "income_statement");
	if (incomeStatement) {
		// Extract unit scale from headers (check all header rows for unit indicators)
		// Sometimes unit indicator is in row 0, sometimes in header row, sometimes in title
		let unitScale = extractUnitScale(incomeStatement.headers);
		
		// Also check table title for unit indicator
		if (unitScale === 1) {
			const titleScale = extractUnitScale([incomeStatement.title]);
			if (titleScale !== 1) {
				unitScale = titleScale;
			}
		}
		
		// Fallback: if no unit indicator found and values are large, assume millions
		// (Most SEC filings use millions for large companies)
		if (unitScale === 1 && incomeStatement.rows.length > 0) {
			// Check first few revenue-related rows to estimate scale
			// Values in 1K-1M range typically indicate millions (e.g., 391,035 = 391 billion)
			for (const row of incomeStatement.rows.slice(0, 10)) {
				const latestValue = getLatestNumericValue(row.values, incomeStatement.metadata.periods);
				if (latestValue !== null && Math.abs(latestValue) >= 1_000 && Math.abs(latestValue) < 1_000_000) {
					// Values in 1K-1M range suggest they're already in millions
					unitScale = 1_000_000;
					break;
				}
			}
		}
		
		for (const row of incomeStatement.rows) {
			const label = row.label.toLowerCase();
			// Get the latest numeric value (most recent period)
			const latestValueRaw = getLatestNumericValue(row.values);
			if (latestValueRaw === null) continue;
			
			// Apply unit scale (convert to base dollars)
			const latestValue = latestValueRaw * unitScale;
			
			// Extract revenue - match various forms: "Total net sales", "Net sales", "Revenue", "Total revenue"
			// Priority: prefer "total" version if exists, but also accept main revenue line without "total"
			if (label.includes("revenue") || label.includes("net sales")) {
				// Skip sub-items like "Product revenue", "Services revenue", "Segment revenue"
				const isSubItem = label.includes("product") || 
				                  label.includes("service") || 
				                  label.includes("segment") ||
				                  label.includes("geographic") ||
				                  label.includes("region");
				
				if (!isSubItem) {
					// Prefer "total" version, but accept if not already set
					if (label.includes("total") || !metrics.revenue) {
						metrics.revenue = latestValue;
					}
				}
			}
			if (label.includes("gross profit") || label.includes("gross margin")) {
				metrics.grossProfit = latestValue;
			}
			if (label.includes("operating income") && !label.includes("non-") && !label.includes("other")) {
				metrics.operatingIncome = latestValue;
			}
			if (label === "net income" || (label.includes("net income") && !label.includes("per share") && !label.includes("adjustment"))) {
				metrics.netIncome = latestValue;
			}
			if (
				(label.includes("earnings per share") || (label.includes("diluted") && !label.includes("weighted"))) &&
				!label.includes("shares used")
			) {
				// EPS is per share, not a total amount, so don't apply unit scale
				// Use raw value directly (already in dollars per share)
				if (typeof latestValueRaw === "number" && Math.abs(latestValueRaw) > 1000) {
					// Likely the row with share counts, skip assigning EPS
				} else {
					metrics.eps = latestValueRaw; // EPS is already in dollars per share
				}
			}
		}

		// Calculate margins if we have the data
		if (metrics.revenue && metrics.grossProfit) {
			metrics.grossMargin = (Number(metrics.grossProfit) / Number(metrics.revenue)) * 100;
		}
		if (metrics.revenue && metrics.operatingIncome) {
			metrics.operatingMargin = (Number(metrics.operatingIncome) / Number(metrics.revenue)) * 100;
		}
		if (metrics.revenue && metrics.netIncome) {
			metrics.netMargin = (Number(metrics.netIncome) / Number(metrics.revenue)) * 100;
		}
	}

	// Balance Sheet metrics
	const balanceSheet = tables.find((t) => t.type === "balance_sheet");
	if (balanceSheet) {
		// Extract unit scale from headers
		let unitScale = extractUnitScale(balanceSheet.headers);
		
		// Also check table title for unit indicator
		if (unitScale === 1) {
			const titleScale = extractUnitScale([balanceSheet.title]);
			if (titleScale !== 1) {
				unitScale = titleScale;
			}
		}
		
		// Fallback: if no unit indicator found and values are large, assume millions
		// Values in 1K-1M range typically indicate millions (e.g., 352,583 = 352 billion)
		if (unitScale === 1 && balanceSheet.rows.length > 0) {
			for (const row of balanceSheet.rows.slice(0, 10)) {
				const latestValue = getLatestNumericValue(row.values, balanceSheet.metadata.periods);
				if (latestValue !== null && Math.abs(latestValue) >= 1_000 && Math.abs(latestValue) < 1_000_000) {
					unitScale = 1_000_000;
					break;
				}
			}
		}
		
		for (const row of balanceSheet.rows) {
			// Clean HTML entities from labels too!
			let label = row.label
				.replace(/&#160;/g, ' ')
				.replace(/&nbsp;/g, ' ')
				.replace(/&#8217;/g, "'")  // Apostrophe
				.replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(dec))
				.toLowerCase()
				.trim();
			
			// Get the latest numeric value (most recent period) using periods metadata
			const latestValueRaw = getLatestNumericValue(row.values, balanceSheet.metadata.periods);
			if (latestValueRaw === null) continue;
			
			// Apply unit scale (convert to base dollars)
			const latestValue = latestValueRaw * unitScale;
			
			if (label.includes("total assets") && !label.includes("liabilities")) {
				metrics.totalAssets = latestValue;
			}
			if (label.includes("total liabilities") && !label.includes("equity")) {
				metrics.totalLiabilities = latestValue;
			}
			// Match "total shareholders' equity" properly (but NOT "total liabilities and shareholders' equity")
			if (label.includes("stockholders") && label.includes("equity") && label.includes("total") && 
			    !label.includes("beginning") && !label.includes("ending") && !label.includes("liabilities")) {
				metrics.totalEquity = latestValue;
			}
			if (label.includes("shareholders") && label.includes("equity") && label.includes("total") && 
			    !label.includes("beginning") && !label.includes("ending") && !label.includes("liabilities")) {
				metrics.totalEquity = latestValue;
			}
			if (label.includes("cash and cash equivalents")) {
				metrics.cash = latestValue;
			}
			if (label.includes("total current assets")) {
				metrics.currentAssets = latestValue;
			}
			if (label.includes("total current liabilities")) {
				metrics.currentLiabilities = latestValue;
			}
		}

		// Calculate ratios
		if (metrics.currentAssets && metrics.currentLiabilities) {
			metrics.currentRatio = Number(metrics.currentAssets) / Number(metrics.currentLiabilities);
		}
		if (metrics.totalLiabilities && metrics.totalEquity) {
			metrics.debtToEquity = Number(metrics.totalLiabilities) / Number(metrics.totalEquity);
		}
		if (metrics.totalEquity && metrics.totalAssets) {
			metrics.equityRatio = (Number(metrics.totalEquity) / Number(metrics.totalAssets)) * 100;
		}
		
		// Calculate ROE (Return on Equity)
		if (metrics.netIncome && metrics.totalEquity) {
			metrics.roe = (Number(metrics.netIncome) / Number(metrics.totalEquity)) * 100;
		}
		
		// Calculate ROA (Return on Assets)
		if (metrics.netIncome && metrics.totalAssets) {
			metrics.roa = (Number(metrics.netIncome) / Number(metrics.totalAssets)) * 100;
		}
	}

	// Cash Flow metrics - search all tables in case detection failed
	// Try cash_flow type first, then search all tables for cash flow keywords
	let cashFlow = tables.find((t) => t.type === "cash_flow");
	
	// If not found, search all tables for cash flow indicators
	if (!cashFlow) {
		cashFlow = tables.find((t) => {
			const text = t.rows.map(r => r.label).join(" ").toLowerCase();
			return text.includes("cash generated by operating") || 
			       text.includes("net cash provided by operating") ||
			       text.includes("cash flows from operating");
		});
	}
	
	if (cashFlow) {
		// Extract unit scale from headers
		let unitScale = extractUnitScale(cashFlow.headers);
		
		// Also check table title for unit indicator
		if (unitScale === 1) {
			const titleScale = extractUnitScale([cashFlow.title]);
			if (titleScale !== 1) {
				unitScale = titleScale;
			}
		}
		
		// Fallback: if no unit indicator found and values are large, assume millions
		// Values in 1K-1M range typically indicate millions (e.g., 122,151 = 122 billion)
		if (unitScale === 1 && cashFlow.rows.length > 0) {
			for (const row of cashFlow.rows.slice(0, 10)) {
				const latestValue = getLatestNumericValue(row.values, cashFlow.metadata.periods);
				if (latestValue !== null && Math.abs(latestValue) >= 1_000 && Math.abs(latestValue) < 1_000_000) {
					unitScale = 1_000_000;
					break;
				}
			}
		}
		
		for (const row of cashFlow.rows) {
			// Clean HTML entities from label before matching
			let label = row.label
				.replace(/&#160;/g, ' ')
				.replace(/&nbsp;/g, ' ')
				.replace(/&#8217;/g, "'")
				.replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(dec))
				.toLowerCase()
				.trim();
			
			// Get the latest numeric value (most recent period) using periods metadata
			const latestValueRaw = getLatestNumericValue(row.values, cashFlow.metadata.periods);
			if (latestValueRaw === null) continue;
			
			// Apply unit scale (convert to base dollars)
			const latestValue = latestValueRaw * unitScale;
			
			// Match various forms of operating cash flow labels
			if (label.includes("cash generated by operating") || 
			    label.includes("net cash provided by operating") ||
			    label.includes("cash flows from operating") ||
			    (label.includes("operating") && label.includes("cash") && 
			     (label.includes("generated") || label.includes("provided")))) {
				metrics.operatingCashFlow = latestValue;
			}
			
			// Match investing cash flow - look for total line
			// Patterns: "Cash flows from investing activities", "Net cash used in investing activities", etc.
			// Skip sub-items like "Purchases of property", "Proceeds from sale", etc.
			if (label.includes("investing activities") || label.includes("cash flows from investing")) {
				// Only match if it's the total line (not sub-items)
				const isSubItem = label.includes("purchases") || 
				                  label.includes("proceeds") && !label.includes("cash flows") ||
				                  label.includes("acquisition") ||
				                  label.includes("sale") && !label.includes("cash flows") ||
				                  label.includes("maturities");
				if (!isSubItem) {
					metrics.investingCashFlow = latestValue;
				}
			}
			
			// Match financing cash flow - look for total line
			// Patterns: "Cash flows from financing activities", "Net cash used in financing activities", etc.
			// Skip sub-items like "Proceeds from issuance", "Repayments", etc.
			if (label.includes("financing activities") || label.includes("cash flows from financing")) {
				// Only match if it's the total line (not sub-items)
				const isSubItem = (label.includes("proceeds from") && !label.includes("cash flows")) ||
				                  label.includes("repayments") ||
				                  label.includes("issuance") && !label.includes("cash flows") ||
				                  label.includes("dividends paid") ||
				                  (label.includes("common stock") && !label.includes("cash flows")) ||
				                  (label.includes("debt") && !label.includes("cash flows"));
				if (!isSubItem) {
					metrics.financingCashFlow = latestValue;
				}
			}
			if (label.includes("free cash flow")) {
				metrics.freeCashFlow = latestValue;
			}
			// Match various forms of CapEx labels
			if (label.includes("capital expenditure") || 
			    label.includes("capex") ||
			    label.includes("payments for acquisition of property") ||
			    label.includes("purchases of property") ||
			    (label.includes("purchases") && label.includes("property") && label.includes("equipment")) ||
			    (label.includes("payments") && label.includes("property") && label.includes("equipment"))) {
				// Parse CapEx value - handle parentheses (negative) and string formats
				let capexValue = latestValue;
				if (typeof capexValue === 'string') {
					// Remove commas, parentheses indicate negative
					const cleaned = capexValue.replace(/,/g, '').trim();
					if (cleaned.startsWith('(') && cleaned.endsWith(')')) {
						capexValue = -parseFloat(cleaned.slice(1, -1));
					} else {
						capexValue = parseFloat(cleaned) || 0;
					}
				}
				// CapEx should be stored as positive (it's an outflow)
				metrics.capex = Math.abs(Number(capexValue));
			}
		}

		// Calculate Free Cash Flow if not directly available
		if (!metrics.freeCashFlow && metrics.operatingCashFlow && metrics.capex) {
			metrics.freeCashFlow = Number(metrics.operatingCashFlow) - Math.abs(Number(metrics.capex));
		}
	}

	// Extract additional items needed for ROIC and WACC
	if (balanceSheet) {
		// Extract unit scale from headers (with fallback logic)
		let unitScale = extractUnitScale(balanceSheet.headers);
		
		// Also check table title for unit indicator
		if (unitScale === 1) {
			const titleScale = extractUnitScale([balanceSheet.title]);
			if (titleScale !== 1) {
				unitScale = titleScale;
			}
		}
		
		// Fallback: if no unit indicator found and values are large, assume millions
		// Values in 10-1M range typically indicate millions (e.g., 10,912 = 10.912 billion)
		// But be careful: values < 10 might be actual dollars, not millions
		if (unitScale === 1 && balanceSheet.rows.length > 0) {
			for (const row of balanceSheet.rows.slice(0, 10)) {
				const latestValue = getLatestNumericValue(row.values, balanceSheet.metadata.periods);
				if (latestValue !== null && Math.abs(latestValue) >= 10 && Math.abs(latestValue) < 1_000_000) {
					// Only apply if value is significant (>= 10) to avoid false positives
					unitScale = 1_000_000;
					break;
				}
			}
		}
		
		let inNonCurrentSection = false;
		let inCurrentSection = false;
		
		for (const row of balanceSheet.rows) {
			// Clean HTML entities from labels
			let label = row.label
				.replace(/&#160;/g, ' ')
				.replace(/&nbsp;/g, ' ')
				.replace(/&#8217;/g, "'")
				.replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(dec))
				.toLowerCase()
				.trim();
			
			// Track which section we're in
			if (label.includes("non-current liabilities")) {
				inNonCurrentSection = true;
				inCurrentSection = false;
			} else if (label.includes("current liabilities")) {
				inCurrentSection = true;
				inNonCurrentSection = false;
			}
			
			// Get the latest numeric value (most recent period) using periods metadata
			const latestValueRaw = getLatestNumericValue(row.values, balanceSheet.metadata.periods);
			if (latestValueRaw === null) continue;
			
			// Apply unit scale (convert to base dollars)
			const latestValue = latestValueRaw * unitScale;
			
			// For ROIC calculation - look for "Term debt" (Apple's terminology) or traditional labels
			if (label.includes("long-term debt") || label.includes("long term debt") || 
			    (label.includes("term debt") && (label.includes("non-current") || inNonCurrentSection))) {
				metrics.longTermDebt = latestValue;
			}
			if (label.includes("short-term debt") || label.includes("short term debt") || 
			    label.includes("current portion of long-term debt") ||
			    (label.includes("term debt") && (label.includes("current") || inCurrentSection) && !label.includes("non-current"))) {
				metrics.shortTermDebt = latestValue;
			}
			// Also check for "Commercial paper" which is short-term debt
			if (label.includes("commercial paper")) {
				const commercialPaper = typeof latestValue === 'number' ? latestValue : 0;
				metrics.shortTermDebt = (metrics.shortTermDebt || 0) + commercialPaper;
			}
		}
	}

	// Calculate ROIC (Return on Invested Capital)
	// ROIC = NOPAT / Invested Capital
	// NOPAT = Operating Income * (1 - Tax Rate)
	// Invested Capital = Total Debt + Total Equity - Cash
	if (metrics.operatingIncome && metrics.totalEquity) {
		// Estimate tax rate from net income and operating income
		let taxRate = 0.21; // Default corporate tax rate
		if (metrics.netIncome && metrics.operatingIncome) {
			const impliedTax = 1 - (Number(metrics.netIncome) / Number(metrics.operatingIncome));
			if (impliedTax > 0 && impliedTax < 1) {
				taxRate = impliedTax;
			}
		}

		const nopat = Number(metrics.operatingIncome) * (1 - taxRate);
		
		// Calculate total debt
		let totalDebt = 0;
		if (metrics.longTermDebt) totalDebt += Number(metrics.longTermDebt);
		if (metrics.shortTermDebt) totalDebt += Number(metrics.shortTermDebt);
		
		// Invested Capital = Debt + Equity - Cash
		const investedCapital = totalDebt + Number(metrics.totalEquity) - (metrics.cash ? Number(metrics.cash) : 0);
		
		if (investedCapital > 0) {
			metrics.roic = (nopat / investedCapital) * 100;
		}
	}

	// Calculate WACC (Weighted Average Cost of Capital)
	// WACC = (E/V * Re) + (D/V * Rd * (1 - Tc))
	// E = Market value of equity (approximated by book value)
	// D = Market value of debt (approximated by book value)
	// V = E + D
	// Re = Cost of equity (estimated using simplified model)
	// Rd = Cost of debt (estimated from interest expense)
	// Tc = Tax rate
	if (metrics.totalEquity && (metrics.longTermDebt || metrics.shortTermDebt)) {
		// Calculate total debt
		let totalDebt = 0;
		if (metrics.longTermDebt) totalDebt += Number(metrics.longTermDebt);
		if (metrics.shortTermDebt) totalDebt += Number(metrics.shortTermDebt);
		
		if (totalDebt > 0) {
			const equity = Number(metrics.totalEquity);
			const totalValue = equity + totalDebt;
			
		// Estimate cost of equity (simplified: use sector-based approach)
		// NOTE: This is a rough estimate. For accurate WACC, use Valuation Agent which considers
		// market cap, beta, risk-free rate, and market risk premium.
		// Financial Understanding Agent provides a basic estimate only.
		let costOfEquity = 0.10; // Base 10% for large-cap companies
		
		// Don't use ROE-based calculation as it's unreliable (ROE can be misleading)
		// Instead, use a conservative sector-based estimate
		// This will be overridden by Valuation Agent's more sophisticated calculation
			
			// Estimate cost of debt (simplified: assume 5% for investment grade)
			// In reality, this should be calculated from interest expense / total debt
			let costOfDebt = 0.05;
			if (incomeStatement) {
				for (const row of incomeStatement.rows) {
					const label = row.label.toLowerCase();
					if (label.includes("interest expense") || label.includes("interest paid")) {
						const interestExpense = Math.abs(Number(row.values[0]));
						costOfDebt = interestExpense / totalDebt;
						break;
					}
				}
			}
			
			// Tax rate
			let taxRate = 0.21;
			if (metrics.netIncome && metrics.operatingIncome) {
				const impliedTax = 1 - (Number(metrics.netIncome) / Number(metrics.operatingIncome));
				if (impliedTax > 0 && impliedTax < 1) {
					taxRate = impliedTax;
				}
			}
			
		// Calculate WACC
		const equityWeight = equity / totalValue;
		const debtWeight = totalDebt / totalValue;
		let calculatedWACC = (equityWeight * costOfEquity + debtWeight * costOfDebt * (1 - taxRate)) * 100;
		
		// Cap WACC at 25% - if calculated higher, it's likely an error
		// This prevents unrealistic values from flawed calculations
		if (calculatedWACC > 25) {
			calculatedWACC = 25; // Cap at reasonable maximum
		}
		
		// Only set WACC if it's reasonable (between 3% and 25%)
		if (calculatedWACC >= 3 && calculatedWACC <= 25) {
			metrics.wacc = calculatedWACC;
		} else {
			// Don't set WACC if calculation is clearly wrong
			// Valuation Agent will provide a more accurate WACC
			metrics.wacc = null; // Mark as unavailable
		}
		}
	}

	return metrics;
}

