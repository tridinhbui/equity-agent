/**
 * Financial Table Parser
 * Identifies and structures financial statements (Income Statement, Balance Sheet, Cash Flow)
 * from raw table data extracted from SEC filings
 */

export interface FinancialTable {
	type: "income_statement" | "balance_sheet" | "cash_flow" | "segment" | "other";
	title: string;
	headers: string[];
	rows: Array<{
		label: string;
		values: (string | number)[];
	}>;
	metadata: {
		periods: string[];
		hasNegatives: boolean;
		hasPercentages: boolean;
	};
}

/**
 * Detect if a table is likely an Income Statement
 */
function isIncomeStatement(table: string[][]): boolean {
	const text = table.flat().join(" ").toLowerCase();
	const keywords = [
		"revenue",
		"net sales",
		"operating income",
		"gross profit",
		"net income",
		"earnings per share",
		"cost of revenue",
		"income from operations",
	];
	return keywords.filter((k) => text.includes(k)).length >= 3;
}

/**
 * Detect if a table is likely a Balance Sheet
 */
function isBalanceSheet(table: string[][]): boolean {
	const text = table.flat().join(" ").toLowerCase();
	const keywords = [
		"total assets",
		"total liabilities",
		"stockholders' equity",
		"current assets",
		"current liabilities",
		"cash and cash equivalents",
		"retained earnings",
	];
	return keywords.filter((k) => text.includes(k)).length >= 3;
}

/**
 * Detect if a table is likely a Cash Flow Statement
 */
function isCashFlowStatement(table: string[][]): boolean {
	const text = table.flat().join(" ").toLowerCase();
	
	// Strong indicators (any 2 of these means it's definitely cash flow)
	const strongKeywords = [
		"cash generated by operating",
		"cash flows from operating",
		"net cash provided by operating",
		"net cash used in operating",
		"cash generated by/(used in) investing",
		"cash flows from investing",
		"cash flows from financing",
	];
	const strongMatches = strongKeywords.filter((k) => text.includes(k)).length;
	if (strongMatches >= 2) return true;
	
	// Weak indicators (need 3+ to match)
	const weakKeywords = [
		"operating activities",
		"investing activities",
		"financing activities",
		"cash flow",
		"depreciation",
		"cash and cash equivalents, beginning",
		"cash and cash equivalents, ending",
	];
	const weakMatches = weakKeywords.filter((k) => text.includes(k)).length;
	
	// If we have 1 strong match + 1 weak match, or 3+ weak matches
	return (strongMatches >= 1 && weakMatches >= 1) || weakMatches >= 3;
}

/**
 * Clean and normalize cell values
 */
function cleanCellValue(val: string): string | number {
	// First, decode HTML entities
	let cleaned = val
		.replace(/&#160;/g, ' ')  // Non-breaking space
		.replace(/&nbsp;/g, ' ')   // Non-breaking space
		.replace(/&amp;/g, '&')    // Ampersand
		.replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(dec)) // Numeric entities
		.trim()
		.replace(/\s+/g, " ");
	
	// Try to parse as number
	// Common formats: 1,234.56  (1,234)  $1,234  123.45%
	const numMatch = cleaned.match(/^[\$]?\(?(\d{1,3}(?:,\d{3})*(?:\.\d+)?)\)?[\%]?$/);
	if (numMatch) {
		const num = parseFloat(numMatch[1].replace(/,/g, ""));
		// If parentheses, it's negative
		if (cleaned.includes("(") && cleaned.includes(")")) {
			return -num;
		}
		return num;
	}
	
	return cleaned;
}

/**
 * Extract period headers (dates, years, quarters)
 */
function extractPeriods(headerRow: string[]): string[] {
	return headerRow
		.slice(1) // Skip first column (usually label)
		.map((h) => h.trim())
		.filter((h) => h.length > 0);
}

/**
 * Parse a single financial table
 */
export function parseFinancialTable(rawTable: string[][]): FinancialTable | null {
	if (rawTable.length < 2) return null;

	// Determine table type
	let type: FinancialTable["type"] = "other";
	let title = "Financial Table";
	
	if (isIncomeStatement(rawTable)) {
		type = "income_statement";
		title = "Income Statement";
	} else if (isBalanceSheet(rawTable)) {
		type = "balance_sheet";
		title = "Balance Sheet";
	} else if (isCashFlowStatement(rawTable)) {
		type = "cash_flow";
		title = "Cash Flow Statement";
	}

	// Find the header row - look for dates/years in the first few rows
	let headerRowIndex = 0;
	let headerRow = rawTable[0];
	
	// Check if row 1 contains dates (like "September 28, 2024")
	if (rawTable.length > 1) {
		const secondRow = rawTable[1];
		const hasDatePattern = secondRow.some(cell => {
			const cleaned = cell.trim();
			return /\d{4}/.test(cleaned) || /September|October|November|December|January/.test(cleaned);
		});
		
		if (hasDatePattern) {
			headerRowIndex = 1;
			headerRow = rawTable[1];
		}
	}
	
	const headers = headerRow.map((h) => h.trim());
	const periods = extractPeriods(headerRow);

	// Parse data rows (skip rows up to and including header)
	const rows: FinancialTable["rows"] = [];
	let hasNegatives = false;
	let hasPercentages = false;

	for (let i = headerRowIndex + 1; i < rawTable.length; i++) {
		const row = rawTable[i];
		if (row.length === 0) continue;

		const label = row[0]?.trim() || "";
		if (!label) continue; // Skip empty labels

		const values = row.slice(1).map(cleanCellValue);
		
		// Check for negatives and percentages
		for (const val of values) {
			if (typeof val === "number" && val < 0) hasNegatives = true;
			if (typeof val === "string" && val.includes("%")) hasPercentages = true;
		}

		rows.push({ label, values });
	}

	if (rows.length === 0) return null;

	return {
		type,
		title,
		headers,
		rows,
		metadata: {
			periods,
			hasNegatives,
			hasPercentages,
		},
	};
}

/**
 * Parse all tables and return structured financial tables
 */
export function parseAllFinancialTables(rawTables: string[][][]): FinancialTable[] {
	const results: FinancialTable[] = [];
	
	for (const rawTable of rawTables) {
		const parsed = parseFinancialTable(rawTable);
		if (parsed) {
			results.push(parsed);
		}
	}
	
	return results;
}

/**
 * Extract key metrics from parsed financial tables
 */
export function extractKeyMetrics(tables: FinancialTable[]): Record<string, any> {
	const metrics: Record<string, any> = {};

	// Income Statement metrics
	const incomeStatement = tables.find((t) => t.type === "income_statement");
	if (incomeStatement) {
		for (const row of incomeStatement.rows) {
			const label = row.label.toLowerCase();
			// Get the first numeric value (skip $ signs)
			const latestValue = row.values.find(v => typeof v === 'number') || row.values[0];
			
			if ((label.includes("revenue") || label.includes("net sales")) && label.includes("total")) {
				metrics.revenue = latestValue;
			}
			if (label.includes("gross profit") || label.includes("gross margin")) {
				metrics.grossProfit = latestValue;
			}
			if (label.includes("operating income") && !label.includes("non-") && !label.includes("other")) {
				metrics.operatingIncome = latestValue;
			}
			if (label === "net income" || (label.includes("net income") && !label.includes("per share") && !label.includes("adjustment"))) {
				metrics.netIncome = latestValue;
			}
			if (label.includes("earnings per share") || (label.includes("diluted") && !label.includes("weighted"))) {
				metrics.eps = latestValue;
			}
		}

		// Calculate margins if we have the data
		if (metrics.revenue && metrics.grossProfit) {
			metrics.grossMargin = (Number(metrics.grossProfit) / Number(metrics.revenue)) * 100;
		}
		if (metrics.revenue && metrics.operatingIncome) {
			metrics.operatingMargin = (Number(metrics.operatingIncome) / Number(metrics.revenue)) * 100;
		}
		if (metrics.revenue && metrics.netIncome) {
			metrics.netMargin = (Number(metrics.netIncome) / Number(metrics.revenue)) * 100;
		}
	}

	// Balance Sheet metrics
	const balanceSheet = tables.find((t) => t.type === "balance_sheet");
	if (balanceSheet) {
		for (const row of balanceSheet.rows) {
			// Clean HTML entities from labels too!
			let label = row.label
				.replace(/&#160;/g, ' ')
				.replace(/&nbsp;/g, ' ')
				.replace(/&#8217;/g, "'")  // Apostrophe
				.replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(dec))
				.toLowerCase()
				.trim();
			
			// Get the first numeric value (skip $ signs)
			const latestValue = row.values.find(v => typeof v === 'number') || row.values[0];
			
			if (label.includes("total assets") && !label.includes("liabilities")) {
				metrics.totalAssets = latestValue;
			}
			if (label.includes("total liabilities") && !label.includes("equity")) {
				metrics.totalLiabilities = latestValue;
			}
			// Match "total shareholders' equity" properly (but NOT "total liabilities and shareholders' equity")
			if (label.includes("stockholders") && label.includes("equity") && label.includes("total") && 
			    !label.includes("beginning") && !label.includes("ending") && !label.includes("liabilities")) {
				metrics.totalEquity = latestValue;
			}
			if (label.includes("shareholders") && label.includes("equity") && label.includes("total") && 
			    !label.includes("beginning") && !label.includes("ending") && !label.includes("liabilities")) {
				metrics.totalEquity = latestValue;
			}
			if (label.includes("cash and cash equivalents")) {
				metrics.cash = latestValue;
			}
			if (label.includes("total current assets")) {
				metrics.currentAssets = latestValue;
			}
			if (label.includes("total current liabilities")) {
				metrics.currentLiabilities = latestValue;
			}
		}

		// Calculate ratios
		if (metrics.currentAssets && metrics.currentLiabilities) {
			metrics.currentRatio = Number(metrics.currentAssets) / Number(metrics.currentLiabilities);
		}
		if (metrics.totalLiabilities && metrics.totalEquity) {
			metrics.debtToEquity = Number(metrics.totalLiabilities) / Number(metrics.totalEquity);
		}
		if (metrics.totalEquity && metrics.totalAssets) {
			metrics.equityRatio = (Number(metrics.totalEquity) / Number(metrics.totalAssets)) * 100;
		}
		
		// Calculate ROE (Return on Equity)
		if (metrics.netIncome && metrics.totalEquity) {
			metrics.roe = (Number(metrics.netIncome) / Number(metrics.totalEquity)) * 100;
		}
		
		// Calculate ROA (Return on Assets)
		if (metrics.netIncome && metrics.totalAssets) {
			metrics.roa = (Number(metrics.netIncome) / Number(metrics.totalAssets)) * 100;
		}
	}

	// Cash Flow metrics - search all tables in case detection failed
	// Try cash_flow type first, then search all tables for cash flow keywords
	let cashFlow = tables.find((t) => t.type === "cash_flow");
	
	// If not found, search all tables for cash flow indicators
	if (!cashFlow) {
		cashFlow = tables.find((t) => {
			const text = t.rows.map(r => r.label).join(" ").toLowerCase();
			return text.includes("cash generated by operating") || 
			       text.includes("net cash provided by operating") ||
			       text.includes("cash flows from operating");
		});
	}
	
	if (cashFlow) {
		for (const row of cashFlow.rows) {
			// Clean HTML entities from label before matching
			let label = row.label
				.replace(/&#160;/g, ' ')
				.replace(/&nbsp;/g, ' ')
				.replace(/&#8217;/g, "'")
				.replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(dec))
				.toLowerCase()
				.trim();
			
			const latestValue = row.values[0];
			
			// Match various forms of operating cash flow labels
			if (label.includes("cash generated by operating") || 
			    label.includes("net cash provided by operating") ||
			    label.includes("cash flows from operating") ||
			    (label.includes("operating") && label.includes("cash") && 
			     (label.includes("generated") || label.includes("provided")))) {
				metrics.operatingCashFlow = latestValue;
			}
			if (label.includes("investing activities") || 
			    label.includes("cash flows from investing")) {
				metrics.investingCashFlow = latestValue;
			}
			if (label.includes("financing activities") ||
			    label.includes("cash flows from financing")) {
				metrics.financingCashFlow = latestValue;
			}
			if (label.includes("free cash flow")) {
				metrics.freeCashFlow = latestValue;
			}
			// Match various forms of CapEx labels
			if (label.includes("capital expenditure") || 
			    label.includes("capex") ||
			    label.includes("payments for acquisition of property") ||
			    label.includes("purchases of property") ||
			    (label.includes("purchases") && label.includes("property") && label.includes("equipment")) ||
			    (label.includes("payments") && label.includes("property") && label.includes("equipment"))) {
				// Parse CapEx value - handle parentheses (negative) and string formats
				let capexValue = latestValue;
				if (typeof capexValue === 'string') {
					// Remove commas, parentheses indicate negative
					const cleaned = capexValue.replace(/,/g, '').trim();
					if (cleaned.startsWith('(') && cleaned.endsWith(')')) {
						capexValue = -parseFloat(cleaned.slice(1, -1));
					} else {
						capexValue = parseFloat(cleaned) || 0;
					}
				}
				// CapEx should be stored as positive (it's an outflow)
				metrics.capex = Math.abs(Number(capexValue));
			}
		}

		// Calculate Free Cash Flow if not directly available
		if (!metrics.freeCashFlow && metrics.operatingCashFlow && metrics.capex) {
			metrics.freeCashFlow = Number(metrics.operatingCashFlow) - Math.abs(Number(metrics.capex));
		}
	}

	// Extract additional items needed for ROIC and WACC
	if (balanceSheet) {
		let inNonCurrentSection = false;
		let inCurrentSection = false;
		
		for (const row of balanceSheet.rows) {
			// Clean HTML entities from labels
			let label = row.label
				.replace(/&#160;/g, ' ')
				.replace(/&nbsp;/g, ' ')
				.replace(/&#8217;/g, "'")
				.replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(dec))
				.toLowerCase()
				.trim();
			
			// Track which section we're in
			if (label.includes("non-current liabilities")) {
				inNonCurrentSection = true;
				inCurrentSection = false;
			} else if (label.includes("current liabilities")) {
				inCurrentSection = true;
				inNonCurrentSection = false;
			}
			
			// Get the first numeric value (skip $ signs)
			const latestValue = row.values.find(v => typeof v === 'number') || row.values[0];
			
			// For ROIC calculation - look for "Term debt" (Apple's terminology) or traditional labels
			if (label.includes("long-term debt") || label.includes("long term debt") || 
			    (label.includes("term debt") && (label.includes("non-current") || inNonCurrentSection))) {
				metrics.longTermDebt = latestValue;
			}
			if (label.includes("short-term debt") || label.includes("short term debt") || 
			    label.includes("current portion of long-term debt") ||
			    (label.includes("term debt") && (label.includes("current") || inCurrentSection) && !label.includes("non-current"))) {
				metrics.shortTermDebt = latestValue;
			}
			// Also check for "Commercial paper" which is short-term debt
			if (label.includes("commercial paper")) {
				const commercialPaper = typeof latestValue === 'number' ? latestValue : 0;
				metrics.shortTermDebt = (metrics.shortTermDebt || 0) + commercialPaper;
			}
		}
	}

	// Calculate ROIC (Return on Invested Capital)
	// ROIC = NOPAT / Invested Capital
	// NOPAT = Operating Income * (1 - Tax Rate)
	// Invested Capital = Total Debt + Total Equity - Cash
	if (metrics.operatingIncome && metrics.totalEquity) {
		// Estimate tax rate from net income and operating income
		let taxRate = 0.21; // Default corporate tax rate
		if (metrics.netIncome && metrics.operatingIncome) {
			const impliedTax = 1 - (Number(metrics.netIncome) / Number(metrics.operatingIncome));
			if (impliedTax > 0 && impliedTax < 1) {
				taxRate = impliedTax;
			}
		}

		const nopat = Number(metrics.operatingIncome) * (1 - taxRate);
		
		// Calculate total debt
		let totalDebt = 0;
		if (metrics.longTermDebt) totalDebt += Number(metrics.longTermDebt);
		if (metrics.shortTermDebt) totalDebt += Number(metrics.shortTermDebt);
		
		// Invested Capital = Debt + Equity - Cash
		const investedCapital = totalDebt + Number(metrics.totalEquity) - (metrics.cash ? Number(metrics.cash) : 0);
		
		if (investedCapital > 0) {
			metrics.roic = (nopat / investedCapital) * 100;
		}
	}

	// Calculate WACC (Weighted Average Cost of Capital)
	// WACC = (E/V * Re) + (D/V * Rd * (1 - Tc))
	// E = Market value of equity (approximated by book value)
	// D = Market value of debt (approximated by book value)
	// V = E + D
	// Re = Cost of equity (estimated using simplified model)
	// Rd = Cost of debt (estimated from interest expense)
	// Tc = Tax rate
	if (metrics.totalEquity && (metrics.longTermDebt || metrics.shortTermDebt)) {
		// Calculate total debt
		let totalDebt = 0;
		if (metrics.longTermDebt) totalDebt += Number(metrics.longTermDebt);
		if (metrics.shortTermDebt) totalDebt += Number(metrics.shortTermDebt);
		
		if (totalDebt > 0) {
			const equity = Number(metrics.totalEquity);
			const totalValue = equity + totalDebt;
			
			// Estimate cost of equity (simplified: assume 10% + risk premium based on ROE)
			let costOfEquity = 0.10; // Base rate
			if (metrics.roe && metrics.roe > 0) {
				// If ROE is high, assume higher cost of equity
				// Convert ROE from percentage to decimal (divide by 100)
				const roeDecimal = Number(metrics.roe) / 100;
				costOfEquity = 0.08 + (roeDecimal * 0.5);
			}
			
			// Estimate cost of debt (simplified: assume 5% for investment grade)
			// In reality, this should be calculated from interest expense / total debt
			let costOfDebt = 0.05;
			if (incomeStatement) {
				for (const row of incomeStatement.rows) {
					const label = row.label.toLowerCase();
					if (label.includes("interest expense") || label.includes("interest paid")) {
						const interestExpense = Math.abs(Number(row.values[0]));
						costOfDebt = interestExpense / totalDebt;
						break;
					}
				}
			}
			
			// Tax rate
			let taxRate = 0.21;
			if (metrics.netIncome && metrics.operatingIncome) {
				const impliedTax = 1 - (Number(metrics.netIncome) / Number(metrics.operatingIncome));
				if (impliedTax > 0 && impliedTax < 1) {
					taxRate = impliedTax;
				}
			}
			
			// Calculate WACC
			const equityWeight = equity / totalValue;
			const debtWeight = totalDebt / totalValue;
			metrics.wacc = (equityWeight * costOfEquity + debtWeight * costOfDebt * (1 - taxRate)) * 100;
		}
	}

	return metrics;
}

